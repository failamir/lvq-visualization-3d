<!DOCTYPE html>
<html lang="en">
  <head>
    <title>three.js webgl - buffergeometry - lines drawrange</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
    />
    <link type="text/css" rel="stylesheet" href="main.css" />
    <style>
      a {
        color: #08f;
      }
    </style>
  </head>
  <body>
    <div id="container"></div>
    <div id="info">
      <a href="http://threejs.org" target="_blank" rel="noopener">three.js</a>
      webgl - buffergeometry drawrange<br />
      by <a href="https://twitter.com/fernandojsg">fernandojsg</a>
    </div>

    <script async type="module">
      import * as THREE from './three.module.js'

      import Stats from './libs/stats.module.js'
      import { GUI } from './libs/dat.gui.module.js'

      import { OrbitControls } from './controls/OrbitControls.js'

      var group
      var container, stats
      var particlesData = []
      var camera, scene, renderer
      var positions, colors
      var particles
      var pointCloud
      var particlePositions
      var linesMesh

      var width = 548,
        height = 640

      var maxParticleCount = 10000
      var particleCount = 500
      var r = 255
      var rHalf = r / 2

      var effectController = {
        showDots: true,
        showLines: true,
        minDistance: 50,
        limitConnections: false,
        maxConnections: 20,
        particleCount: 500
      }

      function loadImg() {
        return new Promise((resolve, reject) => {
          var theImage = new Image()
          theImage.src = './img/newyork.jpg'
          theImage.onload = function() {
            var canvas = document.createElement('canvas')
            var context = canvas.getContext('2d')
            context.drawImage(theImage, 0, 0)
            resolve(context.getImageData(0, 0, width, height).data)
          }
        })
      }

      var pixels = loadImg()
      pixels.then(function(res) {
        var pixels = res
        window.pixels = pixels
        console.log(pixels)

        init()
        animate()

        function initGUI() {
          var gui = new GUI()

          gui.add(effectController, 'showDots').onChange(function(value) {
            pointCloud.visible = value
          })
          gui.add(effectController, 'showLines').onChange(function(value) {
            linesMesh.visible = value
          })
          gui.add(effectController, 'minDistance', 10, 300)
          gui.add(effectController, 'limitConnections')
          gui.add(effectController, 'maxConnections', 0, 30, 1)
          gui
            .add(effectController, 'particleCount', 0, maxParticleCount, 1)
            .onChange(function(value) {
              particleCount = parseInt(value)
              particles.setDrawRange(0, particleCount)
            })
        }

        function init() {
          initGUI()

          container = document.getElementById('container')

          camera = new THREE.PerspectiveCamera(
            45,
            window.innerWidth / window.innerHeight,
            1,
            4000
          )
          camera.position.z = 800

          var controls = new OrbitControls(camera, container)

          scene = new THREE.Scene()

          group = new THREE.Group()
          scene.add(group)

          var helper = new THREE.BoxHelper(
            new THREE.Mesh(new THREE.BoxBufferGeometry(r, r, r))
          )
          helper.material.color.setHex(0x101010)
          helper.material.blending = THREE.AdditiveBlending
          helper.material.transparent = true
          group.add(helper)

          var segments = maxParticleCount * maxParticleCount

          positions = new Float32Array(segments * 3)
          colors = new Float32Array(segments * 3)

          var pMaterial = new THREE.PointsMaterial({
            color: 0x0000ff,
            size: 3,
            blending: THREE.AdditiveBlending,
            transparent: true,
            sizeAttenuation: false
          })

          particles = new THREE.BufferGeometry()
          particlePositions = new Float32Array(maxParticleCount * 3)

          var j = 0
          for (var i = 0; i < maxParticleCount; i++) {
            var x = pixels[j++] - rHalf
            var y = pixels[j++] - rHalf
            var z = pixels[j++] - rHalf
            j++ // for alpha

            particlePositions[i * 3] = x
            particlePositions[i * 3 + 1] = y
            particlePositions[i * 3 + 2] = z

            // add it to the geometry
            particlesData.push({
              velocity: new THREE.Vector3(
                -1 + Math.random() * 2,
                -1 + Math.random() * 2,
                -1 + Math.random() * 2
              ),
              numConnections: 0
            })

            //add single point

            //group.add(pointCloud)
          }

          particles.setDrawRange(0, particleCount)
          particles.addAttribute(
            'position',
            new THREE.BufferAttribute(particlePositions, 3).setDynamic(true)
          )

          // create the particle system
          pointCloud = new THREE.Points(particles, pMaterial)
          group.add(pointCloud)

          renderer = new THREE.WebGLRenderer({ antialias: true })
          renderer.setPixelRatio(window.devicePixelRatio)
          renderer.setSize(window.innerWidth, window.innerHeight)

          renderer.gammaInput = true
          renderer.gammaOutput = true

          container.appendChild(renderer.domElement)

          //

          stats = new Stats()
          container.appendChild(stats.dom)

          window.addEventListener('resize', onWindowResize, false)
        }

        function onWindowResize() {
          camera.aspect = window.innerWidth / window.innerHeight
          camera.updateProjectionMatrix()

          renderer.setSize(window.innerWidth, window.innerHeight)
        }

        function animate() {
          var vertexpos = 0
          var colorpos = 0
          var numConnected = 0

          for (var i = 0; i < particleCount; i++) {
            // get the particle
            var particleData = particlesData[i]
          }

          //  pointCloud.geometry.attributes.position.needsUpdate = true

          requestAnimationFrame(animate)

          stats.update()
          render()
        }

        function render() {
          var time = Date.now() * 0.001

          group.rotation.y = time * 0.1
          renderer.render(scene, camera)
        }
      })
    </script>
  </body>
</html>
